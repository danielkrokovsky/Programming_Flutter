<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <title>Programming Flutter</title>
  <link href="css/bookshelf.css" rel="stylesheet" type="text/css"/>
  <link href="css/book_local.css" rel="stylesheet" type="text/css"/>
  <meta content="urn:uuid:08781442-9212-4868-bf02-b4ef0fd56427" name="Adept.expected.resource"/>
</head>

<body>

  <h2 id="sec.dart.classes">Classes</h2>

  <p id="d24e45667">


Classes in Dart work a lot like classes in other object-oriented languages, but here’s most of what you need to know to get started.</p>

  <h3>Members: Properties and Methods</h3>

  <p id="d24e45682">


Properties are variables declared as members of a class:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">class</strong>​ User {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">int</strong>​ id;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">String</strong>​ username;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">String</strong>​ password;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

  </table>

  <p id="d24e45719">


Methods are functions defined inside classes. They are defined just like top-level functions, but inside the body of a class definition:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">class</strong>​ User {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">int</strong>​ id;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">String</strong>​ username;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">String</strong>​ password;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">void</strong>​ setId(​<strong class="kw">int</strong>​ newId) {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">    id = newId;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  }</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

  </table>

  <h4>Accessing Members: Dot Notation</h4>

  <p id="d24e45772">


Members can be accessed using dot notation. If you wanted to get the <span class="cf variable">id</span> property of the <span class="cf variable">user</span> object and assign it to the <span class="cf variable">a</span> variable, you’d write:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">var</strong>​ a = user.id;</td>
    </tr>

  </table>

  <p id="d24e45806">and you’d run the <span class="cf methodname">setId</span> method like this:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">user.setId(1000)</td>
    </tr>

  </table>

  <h4 id="sec.dart.classes.cascadeNotation">Cascade Notation</h4>

  <p id="d24e45821">



If you need to run multiple methods or change many properties of an object, you can use cascade notation, which allows you to write something like this, which will create a <span class="cf class">User</span> with the given username, password, and ID:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">var</strong>​ a = User()</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ..username=​<em class="string">"yourUsername"</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ..password=​<em class="string">"Actually1veryComplicatedPass!"</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ..setId(1000);</td>
    </tr>

  </table>

  <h3 id="sec.dart.classes.constructors">Constructors</h3>

  <p id="d24e45872">

Dart allows us to define just the constructor’s signature and it will automatically assign the arguments to the corresponding properties and create an instance of the class automatically. The parameters are defined just like any function’s parameters, but pointing to a property of the class:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">class</strong>​ ClassExample {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ClassExample(</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">    ​<strong class="kw">this</strong>​.var1, ​<em class="comment">// positional argument</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">    {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">      @required ​<strong class="kw">this</strong>​.var2, ​<em class="comment">// named arguments</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">      ​<strong class="kw">this</strong>​.var3</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">    }</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  );</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">int</strong>​ var1;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">String</strong>​ var2;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  Function var3;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

  </table>

  <p id="d24e45938">
You can define the constructor for a class inheriting from a superclass in the following way:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">class</strong>​ ClassExample ​<strong class="kw">extends</strong>​ SuperClass {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ClassExample(parameters) :</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">        ​<strong class="kw">super</strong>​(superClassArguments);</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

  </table>

  <h4>Named Constructors</h4>

  <p id="d24e45965">
You can also define <span class="emph">named</span> constructors, which are alternative constructors with a different name:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">class</strong>​ ClassExample {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ClassExample(parameters);</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ClassExample.constructorName(otherParameters);</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

  </table>

  <h4>Regular Constructors</h4>

  <p id="d24e45990">

Dart also supports regular constructor with their own body, that can optionally also take advantage of automatic property assignment.</p>

  <p id="d24e46000">Here’s an example of a class that has a constructor that takes an integer value and assigns its square to the <span class="cf variable">var1</span> while assigning <span class="cf variable">var2</span> and <span class="cf variable">var3</span> directly:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">class</strong>​ ClassExample {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ClassExample(​<strong class="kw">this</strong>​.var1, ​<strong class="kw">this</strong>​.var2, ​<strong class="kw">this</strong>​.var3);</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ClassExample.withSqrtOfVar1(​<strong class="kw">int</strong>​ var1sqrt, ​<strong class="kw">this</strong>​.var2, ​<strong class="kw">this</strong>​.var3) {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">    var1 = var1sqrt*var1sqrt;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  }</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">int</strong>​ var1;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">String</strong>​ var2;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  Function var3;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

  </table>

  <h3 id="sec.dart.methods.static">Static Members</h3>

  <p id="d24e46081">




Static class members can be accessed without requiring instantiation:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">class</strong>​ ClassExample {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<em class="comment">// (...)</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">static</strong>​ ​<strong class="kw">num</strong>​ square(​<strong class="kw">num</strong>​ val) =&gt;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">    val*val;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<em class="comment">// (...)</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<em class="comment">// Unlike in C++, we can use regular dot notation</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">var</strong>​ n = ClassExample.square(0.1);</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<em class="comment">/*</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<em class="comment"> * Comparing floating-point numbers</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<em class="comment"> * using == is unreliable in</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<em class="comment"> * most programming languages,</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<em class="comment"> * including Dart, so use</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<em class="comment"> * syntax like this instead</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<em class="comment"> */</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">assert</strong>​(n &lt; 0.011 &amp;&amp; n &gt; 0.009);</td>
    </tr>

  </table>

  <h3>Abstract Classes</h3>

  <p id="d24e46171">

An <span class="cf ic">abstract class</span> is a class that you can’t instantiate: you can’t create objects of that class. They are declared by substituting the <span class="cf ic">class</span> keyword with <span class="cf ic">abstract class</span>. Abstract classes are usually used as mixins (covered in <a href="#sec.dart.mixins">​<em>Writing a Class with a Mixin</em>​</a>) or interfaces (covered in <a href="#sec.dart.implements">​<em>Writing a Class That implements an Interface</em>​</a>).</p>

  <p id="d24e46196">
An abstract class can contain abstract methods, which are method that don’t have an implementation, but it can also contain regular methods:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">abstract</strong>​ ​<strong class="kw">class</strong>​ MyClass {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">void</strong>​ regularMethod() {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">    ​<em class="comment">// do something</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  }</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">void</strong>​ abstractMethod();</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

  </table>

  <p id="d24e46231">An abstract method may be implemented by either a subclass or a class that implements the <span class="cf class">MyClass</span> interface, as explained in the following sections.</p>

  <h3>Subclasses, Interfaces, and Mixins: extends, implements, and with</h3>

  <p id="d24e46239">

Classes can interact with each other in three ways: a class can be a subclass of another, inheriting all of its members and optionally overriding some of the methods; it can <span class="cf keyword">implement</span> another class’s interface; or it can use methods defined in another class (called a mixin).</p>

  <h4 id="sec.dart.extends">extends</h4>

  <p id="d24e46254">
Especially in Flutter, extending another class is a very common occurrence. By doing that we create a subclass, and the class we extend is called the superclass. We can decide to declare new methods or re-implement (<span class="cf ic">override</span>) existing methods. A subclass can have its own variables and use the superclass’s by accessing the superclass itself through the <span class="cf variable">super</span> object.</p>

  <p><strong>@override</strong></p>

  <p id="d24e46269">


When creating subclasses, you might want to implement one of the superclass’s methods, you can do that by prefixing it with the @override annotation, as we do for the <span class="cf methodname">build</span> method when defining widgets:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">class</strong>​ MyWidget ​<strong class="kw">extends</strong>​ StatelessWidget {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<em class="comment">// (...)</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  @override</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  Widget build(BuildContext context) {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">    ​<em class="comment">// (...)</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  }</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

  </table>

  <p id="d24e46312">the method can also be defined as:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">@override Widget build(context) {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<em class="comment">// (...)</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

  </table>

  <p id="d24e46324">
Sometimes you might want to call the superclass’s corresponding method by adding <span class="cf methodname">super.methodName</span> at the start of the new method’s definition so that the new method acts as an addition, not a replacement, like we have to do when we redefine the <span class="cf class">State</span> class’s <span class="cf methodname">initState</span> when writing <span class="cf class">StatefulWidget</span>s:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">class</strong>​ _MyWidgetState ​<strong class="kw">extends</strong>​ State&lt;StatefulWidget&gt; {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<em class="comment">// (...)</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  @override</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">void</strong>​ initState() {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">    ​<strong class="kw">super</strong>​.initState();</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">    ​<em class="comment">// our own instructions</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  }</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<em class="comment">// (...)</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

  </table>

  <p id="d24e46384">


We have to do that for the <span class="cf class">State</span> class because it has been defined in the Flutter widgets library with the <span class="cf ic">@mustCallSuper</span> annotation, and we can do the same in case we want to define classes for which we think subclasses will be created and a certain overriding method is supposed to call the superclass’s overridden method.

</p>

  <h4 id="sec.dart.mixins">Writing a Class with a Mixin</h4>

  <p id="d24e46411">

A mixin is a class that contains methods to be used by other classes, without requiring those classes to inherit from the mixin directly by extending it and becoming a subclass of it. A mixin can be defined simply as a class and be used by declaring any class that wants to use it (<span class="emph">applying</span> the mixing) <span class="cf ic">with</span> the mixin, like in the following example:
</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<em class="comment">// the mixin</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">class</strong>​ MyMixin {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">String</strong>​ myMethod() =&gt; ​<em class="string">"Hi from the mixin"</em>​;</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">class</strong>​ MyClass ​<strong class="kw">with</strong>​ MyMixin {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">var</strong>​ obj = MyClass();</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">assert</strong>​(obj.myMethod() == ​<em class="string">"Hi from the mixin"</em>​);</td>
    </tr>

  </table>

  <h4 id="sec.dart.implements">Writing a Class That implements an Interface</h4>

  <p id="d24e46480">


An interface is a class that only defines the return type and arguments of its methods, requiring other classes to implement those methods. Fittingly, this is done using the <span class="cf keyword">implements</span> keyword:</p>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">abstract</strong>​ ​<strong class="kw">class</strong>​ MyInterface {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">abstract</strong>​ ​<strong class="kw">void</strong>​ myMethod();</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

  </table>

  <table class="processedcode">

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">class</strong>​ MyClass ​<strong class="kw">implements</strong>​ MyInterface {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">void</strong>​ myMethod() {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">    ​<em class="comment">// do something</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  }</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline"/>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">​<strong class="kw">class</strong>​ MyOtherClass ​<strong class="kw">implements</strong>​ MyInterface {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  ​<strong class="kw">void</strong>​ myMethod() {</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">    ​<em class="comment">// do something else</em>​</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">  }</td>
    </tr>

    <tr>
      <td class="codeinfo">​<span class="codeprefix"> </span></td>
      <td class="codeline">}</td>
    </tr>

  </table>

  <p id="d24e46562">After doing that, you can instantiate and use the <span class="cf class">MyClass</span> and <span class="cf class">MyOtherClass</span>, and you can use them knowing that they implement all of the methods described in <span class="cf class">MyInterface</span>.


</p>

</body>

</html>